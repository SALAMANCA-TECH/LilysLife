// --- Firebase Imports ---
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, setDoc, getDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
import { apiKey as configApiKey } from './config.js';

// --- V2.0 DATABASE DEFINITIONS ---

// --- Firebase & API Globals ---
// NOTE: These variables are 'undefined' in a local environment.
// You will need to replace them with your actual Firebase config and API key for local testing.
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const apiKey = configApiKey || ""; // <-- PASTE YOUR GEMINI API KEY HERE FOR LOCAL TESTING
const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}'); // <-- PASTE YOUR FIREBASE CONFIG OBJECT HERE
let db, auth, userId;

// Base image for the character model
const BASE_MODEL_URL = "https://placehold.co/320x427/27272a/7f7f7f?text=Base+Model"; // Placeholder for 'added-04.jpg'

/**
 * The "Armory" (Clothing Database)
 * NOW INCLUDES 'imageUrl' for the image generation API.
 * Using placeholders as we don't have public URLs for the assets yet.
 */
const clothingDatabase = {
    "underwear": {
        "boyshorts": { 
            name: "Boy-Shorts", 
            stats: { cautious: 1, bold: -1, curious: 0 },
            imageUrl: "https://placehold.co/320x427/ffffff/333333?text=Boyshorts"
        },
        "thong": { 
            name: "Thong", 
            stats: { cautious: -1, bold: 2, curious: 1 },
            imageUrl: "https://placehold.co/320x427/ffffff/333333?text=Thong"
        },
        "none": { 
            name: "Commando", 
            stats: { cautious: -2, bold: 3, curious: 0 },
            imageUrl: null // No image for 'none'
        }
    },
    "bra": {
        "none": { 
            name: "No Bra", 
            stats: { cautious: -1, bold: 1, curious: 1 },
            imageUrl: null
        },
        "sports": { 
            name: "Sports Bra", 
            stats: { cautious: 2, bold: -1, curious: 0 },
            imageUrl: "https://placehold.co/320x427/ffffff/333333?text=Sports+Bra"
        },
        "pushup": {
            name: "Push-up Bra",
            stats: { cautious: 0, bold: 2, curious: 0 },
            imageUrl: "https://placehold.co/320x427/ffffff/333333?text=Pushup+Bra"
        }
    },
    "outfit_top": {
        "hoodie": { 
            name: "Baggy Hoodie", 
            stats: { cautious: 2, bold: -2, curious: 0 },
            imageUrl: "https://placehold.co/320x427/ffffff/333333?text=Hoodie" // Placeholder for 'sweater01.jpg'
        },
        "top": {
            name: "Form-Fitting Top",
            stats: { cautious: -1, bold: 2, curious: 0 },
            imageUrl: "https://placehold.co/320x427/ffffff/333333?text=Fitted+Top"
        }
    },
    "outfit_bottom": {
        "jeans": {
            name: "Jeans",
            stats: { cautious: 1, bold: 0, curious: 0 },
            imageUrl: "https://placehold.co/320x427/ffffff/333333?text=Jeans"
        },
        "skirt": {
            name: "Short Skirt",
            stats: { cautious: -1, bold: 2, curious: 1 },
            imageUrl: "https://placehold.co/320x427/ffffff/333333?text=Skirt"
        }
    },
    "outfit_all": {
        "dress": {
            name: "Simple Dress",
            stats: { cautious: 0, bold: 2, curious: 1 },
            imageUrl: "https://placehold.co/320x427/ffffff/333333?text=Dress"
        }
    },
    "shoes": { // Added shoes as a category
        "chucks": {
            name: "White Chucks",
            stats: { cautious: 0, bold: 0, curious: 0 },
            imageUrl: "https://placehold.co/320x427/ffffff/333333?text=Shoes" // Placeholder for 'WhiteChucks01.jpg'
        },
        "none": {
            name: "Barefoot",
            stats: { cautious: 0, bold: 0, curious: 0 },
            imageUrl: null
        }
    },
    "intent": {
        "intent_cautious": {
            name: "Intent: Cautious",
            stats: { cautious: 1, bold: 0, curious: 0 },
            imageUrl: null
        },
        "intent_curious": {
            name: "Intent: Curious",
            stats: { cautious: 0, bold: 0, curious: 1 },
            imageUrl: null
        },
        "intent_bold": {
            name: "Intent: Bold",
            stats: { cautious: 0, bold: 1, curious: 0 },
            imageUrl: null
        }
    }
};

/**
 * The Story Data
 * This object defines the scenes and choices.
 */
const storyData = {
    "S1_08": {
        // Text is now generated by AI
        choices: [
            { text: "Boy-Shorts", key: "boyshorts", category: "underwear", nextScene: "S1_09" },
            { text: "Thong", key: "thong", category: "underwear", nextScene: "S1_09" },
            { text: "Commando", key: "none", category: "underwear", nextScene: "S1_09" }
        ]
    },
    "S1_09": {
        // Text is now generated by AI
        choices: [
            { text: "Sports Bra", key: "sports", category: "bra", nextScene: "S1_10" },
            { text: "Push-up Bra", key: "pushup", category: "bra", nextScene: "S1_10" },
            { text: "No Bra", key: "none", category: "bra", nextScene: "S1_10" }
        ]
    },
    "S1_10": {
        // Text is now generated by AI
        choices: [
            { text: "Hoodie and Jeans", key: ["hoodie", "jeans"], category: ["outfit_top", "outfit_bottom"], nextScene: "S1_11" },
            { text: "Fitted Top and Skirt", key: ["top", "skirt"], category: ["outfit_top", "outfit_bottom"], nextScene: "S1_11" },
            { text: "Simple Dress", key: "dress", category: "outfit_all", nextScene: "S1_11" }
        ]
    },
    "S1_11": {
        // Text is now generated by AI
        choices: [
            { text: "With Caution. I need to be careful.", key: "intent_cautious", category: "intent", nextScene: "S1_END" },
            { text: "With Curiosity. What will happen?", key: "intent_curious", category: "intent", nextScene: "S1_END" },
            { text: "With Boldness. This is my day.", key: "intent_bold", category: "intent", nextScene: "S1_END" }
        ]
    },
    "S1_END": {
        // Text is now generated by AI
        choices: [
            { text: "Start Over (Reset Prototype)", key: "S1_08", category: "reset", nextScene: "S1_08" }
        ]
    }
};

// --- V2.0 GAME LOGIC ---

/**
 * The "Character Sheet" (Player Stats)
 * This object holds the current state of the game.
 */
let gameState = {
    stats: {
        cautious: 0,
        curious: 0,
        bold: 0
    },
    equipped: {
        bra: null,
        underwear: null,
        outfit_top: null,
        outfit_bottom: null,
        outfit_all: null,
        shoes: "chucks", // Defaulting to having shoes on
        intent: null
    },
    currentScene: "S1_08",
    userId: null // Will be set after auth
};

// --- DOM Element References ---
let narrativeContainer, choicesContainer, meterBarCautious, meterBarCurious, meterBarBold, characterImage, sceneImage, loadingOverlay, saveButton, loadButton;

// Set a maximum value for the meters to calculate percentages
const MAX_STAT_VALUE = 10; 

/**
 * Recalculates the player's stats based on equipped items.
 */
function recalculateStats() {
    // Reset stats to 0
    let newStats = { cautious: 0, curious: 0, bold: 0 };

    // Loop through every slot in 'equipped'
    for (const category in gameState.equipped) {
        const itemId = gameState.equipped[category];
        if (itemId) {
            // Find the item in the database
            const item = clothingDatabase[category]?.[itemId];
            if (item && item.stats) {
                // Add item's stats to the total
                newStats.cautious += item.stats.cautious;
                newStats.curious += item.stats.curious;
                newStats.bold += item.stats.bold;
            }
        }
    }
    
    // Update the global gameState
    gameState.stats = newStats;
}

/**
 * Updates the UI meters based on the current gameState.
 */
function updateMeters() {
    if (!meterBarCautious || !meterBarCurious || !meterBarBold) return;

    // Calculate percentage, ensuring it's between 0 and 100
    const cautiousPercent = Math.max(0, Math.min(100, (gameState.stats.cautious / MAX_STAT_VALUE) * 100));
    const curiousPercent = Math.max(0, Math.min(100, (gameState.stats.curious / MAX_STAT_VALUE) * 100));
    const boldPercent = Math.max(0, Math.min(100, (gameState.stats.bold / MAX_STAT_VALUE) * 100));

    // Update the style
    meterBarCautious.style.width = `${cautiousPercent}%`;
    meterBarCurious.style.width = `${curiousPercent}%`;
    meterBarBold.style.width = `${boldPercent}%`;
}

/**
 * Toggles the loading overlay.
 */
function setLoading(isLoading) {
    if (isLoading) {
        loadingOverlay.classList.remove('hidden');
        loadingOverlay.classList.add('flex');
    } else {
        loadingOverlay.classList.add('hidden');
        loadingOverlay.classList.remove('flex');
    }
}

// --- AI API FUNCTIONS ---

/**
 * Helper function to fetch an image from a URL and convert it to a Gemini-compatible format.
 * NOTE: This will not work if the images are on a different domain without CORS enabled.
 * A proxy is used as a workaround for this prototype.
 */
async function urlToGenerativePart(url) {
    // A proxy is used to bypass CORS issues with placehold.co in a browser environment.
    const proxyUrl = `https://cors-anywhere.herokuapp.com/${url}`;
    const response = await fetch(proxyUrl);
    if (!response.ok) {
        throw new Error(`Failed to fetch image from ${url}: ${response.statusText}`);
    }
    const blob = await response.blob();
    const mimeType = blob.type;
    const arrayBuffer = await blob.arrayBuffer();
    // A classic way to Base64-encode an ArrayBuffer in the browser.
    const base64Data = btoa(new Uint8Array(arrayBuffer).reduce((data, byte) => data + String.fromCharCode(byte), ''));
    return {
        inlineData: {
            data: base64Data,
            mimeType
        }
    };
}

/**
 * (AI TASK 1) Generates the character image by combining layers.
 * This has been refactored to use gemini-pro-vision and sends base64 image data directly.
 */
async function generateCharacterImage() {
    if (!apiKey) {
        console.warn("Missing API key, skipping image generation.");
        characterImage.src = "https://placehold.co/320x427/27272a/ffffff?text=Image+Generation+Skipped+(No+API+Key)";
        return;
    }
    setLoading(true);
    const proxyUrl = 'https://cors-anywhere.herokuapp.com/';
    const apiUrl = `${proxyUrl}https://generativelanguage.googleapis.com/v1beta/models/gemini-pro-vision:generateContent?key=${apiKey}`;
    
    try {
        // --- 1. Collect Image URLs ---
        let imageUrls = [BASE_MODEL_URL]; // Start with the base model
        let clothingDesc = [];

        for (const category in gameState.equipped) {
            const itemId = gameState.equipped[category];
            if (itemId) {
                const item = clothingDatabase[category]?.[itemId];
                if (item && item.imageUrl) {
                    imageUrls.push(item.imageUrl);
                    clothingDesc.push(item.name);
                }
            }
        }

        // --- 2. Fetch and Prepare Image Data ---
        // Use Promise.all to fetch all images concurrently using the helper.
        console.log("Fetching images for generation:", imageUrls);
        const imageParts = await Promise.all(imageUrls.map(url => urlToGenerativePart(url)));
        console.log("Image parts prepared successfully.");

        // --- 3. Construct the Prompt and Payload ---
        const userPrompt = `Combine the equipped clothing items onto the base character model. The first image is the base model, and the subsequent images are the clothing items to be layered on top: ${clothingDesc.join(', ')}. The final image should be one coherent character portrait with all items worn correctly, rendered in a realistic style.`;

        const payload = {
            contents: [{
                parts: [
                    { text: userPrompt },
                    ...imageParts // Spread the array of image parts
                ]
            }],
        };

        // --- 4. Make the API Call (with backoff) ---
        let response;
        let retries = 0;
        const maxRetries = 3;
        while (retries < maxRetries) {
            response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (response.ok) break;

            retries++;
            const delay = Math.pow(2, retries) * 1000;
            console.warn(`API call failed with status ${response.status}. Retrying in ${delay}ms...`);
            await new Promise(res => setTimeout(res, delay));
        }

        if (!response.ok) {
            const errorBody = await response.text();
            console.error("API response error body:", errorBody);
            throw new Error(`API call failed after ${maxRetries} retries with status ${response.status}`);
        }

        const result = await response.json();
        const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;

        if (base64Data) {
            characterImage.src = `data:image/png;base64,${base64Data}`;
        } else {
            console.error("Image generation failed. API Response:", result);
            // Log the full response if the expected data isn't there.
            if (result.candidates && result.candidates[0].finishReason !== 'STOP') {
                console.error("Image generation stopped for reason:", result.candidates[0].finishReason);
                console.error("Safety Ratings:", result.candidates[0].safetyRatings);
            }
            characterImage.src = "https://placehold.co/320x427/c70000/ffffff?text=Image+Gen+Failed";
        }
    } catch (error) {
        console.error("Error during image generation process:", error);
        characterImage.src = "https://placehold.co/320x427/c70000/ffffff?text=Image+Gen+Error";
    } finally {
        setLoading(false);
    }
}

/**
 * (AI TASK 3) Generates the narrative text for a scene.
 */
async function generateNarrative(sceneId) {
    if (!apiKey) {
        console.warn("Missing API key, skipping narrative generation.");
        narrativeContainer.innerHTML = `<p class="mb-4 text-gray-500">Narrative generation skipped (No API Key).</p>`;
        return;
    }
    setLoading(true);
    narrativeContainer.innerHTML = `<p class="mb-4 text-gray-500">Generating narrative...</p>`;
    // Note: The model was already updated. This confirms the endpoint structure for gemini-pro.
    const proxyUrl = 'https://cors-anywhere.herokuapp.com/';
    const apiUrl = `${proxyUrl}https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`;

    const systemPrompt = `You are Delilah, a narrative co-author for an interactive game. Your role is to write the descriptive prose for a scene. You must not violate content policies. Focus on internal monologue, atmosphere, and identity. Keep the text to a single, engaging paragraph.`;
    
    const userQuery = `Write the narrative text for scene '${sceneId}'.
        The player's current stats are:
        - Cautious: ${gameState.stats.cautious}
        - Curious: ${gameState.stats.curious}
        - Bold: ${gameState.stats.bold}
        
        The player just equipped: ${JSON.stringify(gameState.equipped)}
        
        Based on these stats, write a brief, non-sensitive, SFW paragraph (about 2-3 sentences) describing the character's internal thoughts as they progress through this stage of getting dressed ('${sceneId}').`;

    const payload = {
        contents: [{ parts: [{ text: userQuery }] }],
        systemInstruction: {
            parts: [{ text: systemPrompt }]
        },
    };

    try {
        // Implement exponential backoff for API calls
        let response;
        let retries = 0;
        const maxRetries = 3;
        while (retries < maxRetries) {
            response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (response.ok) {
                break; // Success
            }

            retries++;
            const delay = Math.pow(2, retries) * 1000;
            console.warn(`API call failed with status ${response.status}. Retrying in ${delay}ms...`);
            await new Promise(res => setTimeout(res, delay));
        }

        if (!response.ok) {
            throw new Error(`API call failed after ${maxRetries} retries with status ${response.status}`);
        }

        const result = await response.json();
        const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

        if (text) {
            narrativeContainer.innerHTML = `<p class="mb-4 opacity-0 transition-opacity duration-500 ease-in-out">${text}</p>`;
            setTimeout(() => {
                narrativeContainer.querySelector('p')?.classList.remove('opacity-0');
            }, 50);
        } else {
            console.error("Narrative generation failed:", result);
            narrativeContainer.innerHTML = `<p class="mb-4 text-red-400">Error generating narrative.</p>`;
        }
    } catch (error) {
        console.error("Error calling text API:", error);
        narrativeContainer.innerHTML = `<p class="mb-4 text-red-400">Error connecting to narrative AI.</p>`;
    } finally {
        setLoading(false);
    }
}

// --- FIREBASE SAVE/LOAD FUNCTIONS ---

/**
 * (SAVE/LOAD TASK) Saves the current gameState to Firestore.
 */
async function saveGame() {
    if (!userId) {
        console.error("Not authenticated. Cannot save.");
        return;
    }
    setLoading(true);
    console.log(`Saving game for userId: ${userId}`);
    try {
        const savePath = doc(db, 'artifacts', appId, 'users', userId, 'lily-save', 'slot-1');
        await setDoc(savePath, gameState);
        console.log("Game saved!");
        saveButton.textContent = "Saved!";
        setTimeout(() => { saveButton.textContent = "Save Game"; }, 2000);
    } catch (error) {
        console.error("Error saving game:", error);
        saveButton.textContent = "Save Failed!";
        setTimeout(() => { saveButton.textContent = "Save Game"; }, 2000);
    } finally {
        setLoading(false);
    }
}

/**
 * (SAVE/LOAD TASK) Loads the gameState from Firestore.
 */
async function loadGame() {
    if (!userId) {
        console.error("Not authenticated. Cannot load.");
        return;
    }
    setLoading(true);
    console.log(`Loading game for userId: ${userId}`);
    try {
        const savePath = doc(db, 'artifacts', appId, 'users', userId, 'lily-save', 'slot-1');
        const docSnap = await getDoc(savePath);
        
        if (docSnap.exists()) {
            gameState = docSnap.data();
            console.log("Game loaded!");
            
            // Re-render the UI with loaded data
            recalculateStats();
            updateMeters();
            await renderScene(gameState.currentScene); // Re-render narrative and choices
            
            // Also regenerate image for the loaded state
            if(gameState.currentScene === 'S1_END') {
                await generateCharacterImage();
            }

            loadButton.textContent = "Loaded!";
            setTimeout(() => { loadButton.textContent = "Load Game"; }, 2000);
        } else {
            console.log("No save file found.");
            loadButton.textContent = "No Save!";
            setTimeout(() => { loadButton.textContent = "Load Game"; }, 2000);
        }
    } catch (error) {
        console.error("Error loading game:", error);
        loadButton.textContent = "Load Failed!";
        setTimeout(() => { loadButton.textContent = "Load Game"; }, 2000);
    } finally {
        setLoading(false);
    }
}

/**
 * Handles a player's choice.
 */
function handleChoice(choice) {
    const { key, category, nextScene } = choice;

    // Handle "reset" choice
    if (category === "reset") {
        // Reset game state
        gameState.stats = { cautious: 0, curious: 0, bold: 0 };
        gameState.equipped = {
            bra: null,
            underwear: null,
            outfit_top: null,
            outfit_bottom: null,
            outfit_all: null,
            shoes: "chucks",
            intent: null
        };
        // Reset character image to base
        characterImage.src = BASE_MODEL_URL;
    } 
    // Handle array of items (e.g., top and bottom)
    else if (Array.isArray(category)) {
        // Clear 'outfit_all' if a top/bottom is chosen
        gameState.equipped.outfit_all = null;
        category.forEach((cat, index) => {
            gameState.equipped[cat] = key[index];
        });
    } 
    // Handle single item
    else {
        // If 'outfit_all' is chosen, clear top/bottom
        if (category === 'outfit_all') {
            gameState.equipped.outfit_top = null;
            gameState.equipped.outfit_bottom = null;
        }
        gameState.equipped[category] = key;
    }

    // Recalculate stats and update UI after any choice
    recalculateStats();
    updateMeters();

    // Render the next scene
    renderScene(nextScene);
}

/**
 * Renders a new scene in the UI.
 * NOW calls AI for narrative text.
 */
async function renderScene(sceneId) {
    gameState.currentScene = sceneId;
    const scene = storyData[sceneId];

    if (!scene) {
        console.error(`Scene '${sceneId}' not found!`);
        narrativeContainer.innerHTML = `<p class="mb-4 text-red-400">Error: Scene not found.</p>`;
        return;
    }

    // Update narrative text using AI
    await generateNarrative(sceneId);

    // Clear old choices
    choicesContainer.innerHTML = '';

    // Create and append new choices
    scene.choices.forEach((choice, index) => {
        const button = document.createElement('button');
        button.textContent = choice.text;
        button.className = "choice-button w-full p-3 bg-gray-700 rounded-lg text-left text-indigo-300 hover:bg-indigo-600 hover:text-white transform opacity-0 translate-y-2";
        button.onclick = () => handleChoice(choice);
        choicesContainer.appendChild(button);

        // Animate choices in
        setTimeout(() => {
            button.classList.remove('opacity-0', 'translate-y-2');
        }, 100 * (index + 1));
    });

    // (AI TASK 1) Trigger image generation only on the final scene
    if (sceneId === 'S1_END') {
        await generateCharacterImage();
    }
}

/**
 * Initializes Firebase connection.
 */
async function initializeFirebase() {
    // Check if Firebase config is provided
    if (!firebaseConfig.apiKey) {
        console.error("Firebase config is missing. Running in 'offline' mode.");
        console.warn("Save/Load functionality will be disabled.");
        
        // Disable save/load buttons
        if (saveButton) saveButton.disabled = true;
        if (loadButton) loadButton.disabled = true;
        
        // Render the first scene without auth
        await renderScene(gameState.currentScene);
        updateMeters();
        return; // Stop initialization
    }

    try {
        const app = initializeApp(firebaseConfig);
        auth = getAuth(app);
        db = getFirestore(app);
        setLogLevel('Debug'); // Enable Firestore logging

        // Sign in
        // Use a placeholder token for local dev if __initial_auth_token__ isn't present
        const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        if (token) {
            await signInWithCustomToken(auth, token);
        } else {
            console.warn("No auth token found, signing in anonymously for local dev.");
            await signInAnonymously(auth);
        }
        
        userId = auth.currentUser.uid;
        gameState.userId = userId;
        console.log("Firebase Initialized. User ID:", userId);
        
        // Now that Firebase is ready, render the first scene
        await renderScene(gameState.currentScene);
        updateMeters();

    } catch (error) {
        console.error("Firebase initialization error:", error);
        narrativeContainer.innerHTML = `<p class="mb-4 text-red-400">Error: Firebase connection failed. ${error.message}</p>`;
        // Still try to render the scene, but save/load will fail
        await renderScene(gameState.currentScene);
        updateMeters();
    }
}


// --- INITIALIZATION ---

/**
 * Initialize the game when the DOM is loaded.
 */
document.addEventListener('DOMContentLoaded', () => {
    // Get all DOM element references
    narrativeContainer = document.getElementById('narrative-container');
    choicesContainer = document.getElementById('choices-container');
    meterBarCautious = document.getElementById('meter-bar-cautious');
    meterBarCurious = document.getElementById('meter-bar-curious');
    meterBarBold = document.getElementById('meter-bar-bold');
    characterImage = document.getElementById('character-image');
    sceneImage = document.getElementById('scene-image');
    loadingOverlay = document.getElementById('loading-overlay');
    saveButton = document.getElementById('save-button');
    loadButton = document.getElementById('load-button');

    // Add event listeners for save/load
    saveButton.onclick = saveGame;
    loadButton.onclick = loadGame;

    // Start the game by initializing Firebase
    // This will, in turn, call renderScene
    initializeFirebase();
});